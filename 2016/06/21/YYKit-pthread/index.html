<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> YYKit源码分析---pthread · dreamerpanda</title><meta name="description" content="YYKit源码分析---pthread - panda"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="dreamerpanda"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">YYKit源码分析---pthread</h1><div class="post-info">Jun 21, 2016</div><div class="post-content"><p>大家都知道ibireme的<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYKit</a>很强大，个人也特别佩服ibireme。大神常常教导我们这样的小白说：多读源码能够大幅度的提高功力。 </p><p>每当项目上线后，需求还没有下来时，都会有一段闲暇时间。这段时间学习是极佳的。YYKit这个框架刚开始看的时候就遇到pthread这个玩意，之前很少接触。在此，记录自己的所学所得，并分享给大家。<br><a id="more"></a></p>
<h2 id="u5148_u6765_u770B_u4E0BYY_u5B9A_u4E49_u7684_u5B8F"><a href="#u5148_u6765_u770B_u4E0BYY_u5B9A_u4E49_u7684_u5B8F" class="headerlink" title="先来看下YY定义的宏"></a>先来看下YY定义的宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void pthread_mutex_init_recursive(pthread_mutex_t *mutex, bool recursive) &#123;&#10;#define YYMUTEX_ASSERT_ON_ERROR(x_) do &#123; \&#10;__unused volatile int res = (x_); \&#10;assert(res == 0); \&#10;&#125; while (0)&#10;    assert(mutex != NULL);&#10;    if (!recursive) &#123;&#10;        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init(mutex, NULL));&#10;    &#125; else &#123;&#10;        pthread_mutexattr_t attr;&#10;        &#10;        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_init (&#38;attr));&#10;        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_settype (&#38;attr, PTHREAD_MUTEX_RECURSIVE));&#10;        YYMUTEX_ASSERT_ON_ERROR(pthread_mutex_init (mutex, &#38;attr));&#10;        YYMUTEX_ASSERT_ON_ERROR(pthread_mutexattr_destroy (&#38;attr));&#10;    &#125;&#10;#undef YYMUTEX_ASSERT_ON_ERROR&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>大神的代码都是晦涩难懂的，看到这段代码后劳资突然产生了好几个问题：</p>
<ul>
<li>这个方法是用来干嘛的呢？</li>
<li>pthread_mutex_t是什么鬼？</li>
<li>pthread_mutexattr_t是用来配置pthread_mutex_t的吗？</li>
</ul>
<h2 id="u89E3_u8BFB"><a href="#u89E3_u8BFB" class="headerlink" title="解读"></a>解读</h2><h4 id="u529F_u80FD"><a href="#u529F_u80FD" class="headerlink" title="功能"></a>功能</h4><p>其实就是创建个互斥线程，并没有想象中的可怕</p>
<h4 id="pthread_mutex_t"><a href="#pthread_mutex_t" class="headerlink" title="pthread_mutex_t"></a>pthread_mutex_t</h4><p><code>int pthread_mutex_init(pthread_mutex_t * __restrict,
        const pthread_mutexattr_t * __restrict);</code> 是用这个函数创建出来的。函数是以动态的方式创建互斥锁的，参数attr指定了新建互斥锁的属性。<br><code>recursive</code>这个<code>bool</code>值为false时，attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。<br><code>recursive</code>这个<code>bool</code>值为true时，配置互斥锁属性创建相应的互斥锁。</p>
<h4 id="YYMUTEX_ASSERT_ON_ERROR"><a href="#YYMUTEX_ASSERT_ON_ERROR" class="headerlink" title="YYMUTEX_ASSERT_ON_ERROR"></a>YYMUTEX_ASSERT_ON_ERROR</h4><p>断言来进行检查错误，所有操作返回非0时，表示有异常错误发生</p>
<h4 id="Mutex_type_attributes"><a href="#Mutex_type_attributes" class="headerlink" title="Mutex type attributes"></a>Mutex type attributes</h4><p><strong>PTHREAD_MUTEX_NORMAL</strong>：不进行deadlock detection（死锁检测）。当进行relock时，这个mutex就导致deadlock。对一个没有进行lock或者已经unlock的对象进行unlock操作，结果也是未知的。<br><strong>PTHREAD_MUTEX_ERRORCHECK</strong>：和PTHREAD_MUTEX_NORMAL相比，PTHREAD_MUTEX_ERRORCHECK会进行错误检测，以上错误行为都会返回一个错误。<br><strong>PTHREAD_MUTEX_RECURSIVE</strong>：和semaphore（信号量）有个类似的东西，mutex会有个锁住次数的概念，第一次锁住mutex的时候，锁住次数设置为1，每一次一个线程unlock这个mutex时，锁住次数就会减1。当锁住次数为0时，其他线程就可以获得该mutex锁了。同样，对一个没有进行lock或者已经unlock的对象进行unlock操作，将返回一个错误。<br><strong>PTHREAD_MUTEX_DEFAULT</strong>：默认PTHREAD_MUTEX_NORMAL。</p>
<h2 id="u518D_u770B_u770BYY_u5982_u4F55_u4F7F_u7528_u8BE5_u5B8F"><a href="#u518D_u770B_u770BYY_u5982_u4F55_u4F7F_u7528_u8BE5_u5B8F" class="headerlink" title="再看看YY如何使用该宏"></a>再看看YY如何使用该宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay &#123;&#10;    YYImageFrame *result = nil;&#10;    pthread_mutex_lock(&#38;_lock);&#10;    result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay];&#10;    pthread_mutex_unlock(&#38;_lock);&#10;    return result;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这边为了防止多线程资源抢夺的问题，先进行lock下，等数据操作完毕后释放unlock，有没有一种豁然开朗的感觉呢<br>平时我们在多线程操作的时候也可以使用NSLock、synchronized来进行加锁，yy使用了更加偏向底层的pthread</strong></p>
<h2 id="pthread_t_u548CNSThread"><a href="#pthread_t_u548CNSThread" class="headerlink" title="pthread_t和NSThread"></a>pthread_t和NSThread</h2><p>两者都是用来操作线程的对象，平时我们使用上层的NSThread比较多，像[NSThread mainThread]获取主线程，[NSThread currentThread] 获取当前线程。pthread_t和NSThread是一一对应的，同样可以通过pthread_main_thread_np() 、pthread_self()来获取。NSThread只是对pthread_t的一层封装而已。</p>
<h2 id="u5B9E_u6218"><a href="#u5B9E_u6218" class="headerlink" title="实战"></a>实战</h2><ul>
<li>声明函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *func(void *argu) &#123;&#10;    char *m = (char *)argu;&#10;&#10;    pthread_mutex_lock(&#38;mutex);&#10;    while (*m != &#39;\0&#39;) &#123;&#10;        printf(&#34;%c&#34;, *m);&#10;        fflush(stdout);&#10;        sleep(3);&#10;        m++;&#10;    &#125;&#10;    printf(&#34;\n&#34;);&#10;    pthread_mutex_unlock(&#38;mutex);&#10;    return 0;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutex使用 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   int rc1, rc2;&#10;   &#10;   char *str1 = &#34;Hi&#34;;&#10;   char *str2 = &#34;Boy!&#34;;&#10;   &#10;   pthread_t thread1, thread2;&#10;   pthread_mutex_init(&#38;mutex, NULL);&#10;&#10;   if ((rc1 = pthread_create(&#38;thread1, NULL, func, str1))) &#123;&#10;       fprintf(stdout, &#34;thread1 creat fail : %d \n!&#34;, rc1);&#10;   &#125;&#10;   if ((rc2 = pthread_create(&#38;thread2, NULL, func, str2))) &#123;&#10;       fprintf(stdout, &#34;thread2 creat fail : %d \n!&#34;, rc2);&#10;   &#125;&#10;&#10;   // https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/pthread_join.3.html#//apple_ref/c/func/pthread_join&#10;   // &#31561;&#24453;&#19968;&#20010;&#32447;&#31243;&#30340;&#32467;&#26463;&#65292;&#24403;&#20989;&#25968;&#36820;&#22238;&#26102;&#65292;&#34987;&#31561;&#24453;&#30340;&#32447;&#31243;&#36164;&#28304;&#34987;&#25910;&#22238;&#12290;&#33509;&#32447;&#31243;&#24050;&#32463;&#34987;&#25910;&#22238;&#65292;&#37027;&#20040;&#35813;&#20989;&#25968;&#20250;&#31435;&#21363;&#36820;&#22238;&#10;   pthread_join(thread1, NULL);&#10;   pthread_join(thread2, NULL);&#10;&#10;printf(&#34;&#36825;&#36793;&#21482;&#26377;&#32447;&#31243;&#34987;&#22238;&#25910;&#21518;&#25165;&#20250;&#25191;&#34892;&#65281;&#34;);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以帮pthread_mutex_lock(&amp;mutex)和pthread_mutex_unlock(&amp;mutex)注释掉看下打印<p></p></li>
</ul>
<blockquote>
<p>感谢大家花费时间来查看这篇blog，需要下载demo的同学请猛戳<a href="https://github.com/PanXianyue/BlogDemo" target="_blank" rel="external">Git</a>。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/18/YYCache-analyzing/" class="prev">PREV</a><a href="/2016/05/11/Runtime-tabBarItem/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">panda</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>