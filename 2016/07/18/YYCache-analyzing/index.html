<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> YYKit源码分析---YYCache · dreamerpanda</title><meta name="description" content="YYKit源码分析---YYCache - panda"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="dreamerpanda"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">YYKit源码分析---YYCache</h1><div class="post-info">Jul 18, 2016</div><div class="post-content"><p><a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路ibireme已经讲得很清楚了，我这边就不在分析了。</p>
<a id="more"></a>
<h2 id="u6587_u4EF6_u7ED3_u6784"><a href="#u6587_u4EF6_u7ED3_u6784" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="http://7xq5ax.com1.z0.glb.clouddn.com/yycache-tree.png" alt=""></p>
<ol>
<li>YYCache：同时实现内存缓存和磁盘缓存且是线程安全的</li>
<li>YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能</li>
<li>YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式</li>
<li>YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的</li>
</ol>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>LRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰</p>
<p></p><p><br><img src="http://7xq5ax.com1.z0.glb.clouddn.com/lru.png" alt=""></p>
<p></p><p><br>简单的来说3点：</p>
<ol>
<li>有新数据加入时添加到链表的头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃</li>
</ol>
<p><strong>在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍</strong></p>
<h2 id="u5173_u4E8E_u9501"><a href="#u5173_u4E8E_u9501" class="headerlink" title="关于锁"></a>关于锁</h2><p>YYCache 使用到两种锁</p>
<ol>
<li>OSSpinLock ：自旋锁，上一篇博客也提及到<a href="http://iipanda.com/2016/06/21/YYKit-pthread/" target="_blank" rel="external">pthread_mutex</a> </li>
<li>dispatch_semaphore：信号量，当信号量为1的时候充当锁来用</li>
</ol>
<p><strong>内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源<br>磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源</strong></p>
<blockquote>
<p>简单的科普就到这，现在来开始源码的探索</p>
</blockquote>
<h2 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface _YYLinkedMapNode : NSObject &#123;&#10;    @package&#10;    __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic&#10;    __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic&#10;    id _key;&#10;    id _value;&#10;    NSUInteger _cost;&#10;    NSTimeInterval _time;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p><strong>_YYLinkedMapNode</strong>：链表的节点<br><br>_prev、_next：分别表示指向上一个节点、下一个节点<br><br>_key：缓存的key<br><br>_value：缓存对象<br><br>_cost：内存消耗<br><br>_time：缓存时间<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface _YYLinkedMap : NSObject &#123;&#10;    @package&#10;    CFMutableDictionaryRef _dic; // do not set object directly&#10;    NSUInteger _totalCost;&#10;    NSUInteger _totalCount;&#10;    _YYLinkedMapNode *_head; // MRU&#65288;&#26368;&#36817;&#26368;&#24120;&#20351;&#29992;&#31639;&#27861;&#65289;, do not change it directly&#10;    _YYLinkedMapNode *_tail; // LRU&#65288;&#26368;&#36817;&#26368;&#23569;&#20351;&#29992;&#31639;&#27861;-&#28165;&#38500;&#36739;&#19981;&#24120;&#20351;&#29992;&#25968;&#25454;&#65289;, do not change it directly&#10;    BOOL _releaseOnMainThread;&#10;    BOOL _releaseAsynchronously;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_YYLinkedMap</strong>：链表<br><br>_dic：用来保存节点<br><br>_totalCost：总缓存开销<br><br>_head、_tail：头节点、尾节点<br><br>_releaseOnMainThread：是否在主线程释放_YYLinkedMapNode<br><br>_releaseAsynchronously：是否异步释放_YYLinkedMapNode<br></p>
<p><strong>双向链表</strong><br><br><img src="http://7xq5ax.com1.z0.glb.clouddn.com/LinkedMap@1x.png" alt=""></p>
<ol>
<li>插入节点到头部</li>
<li>将除两边的节点移到头部</li>
<li>移除除两边的节点</li>
<li>移除尾部节点</li>
<li>移除所有节点</li>
</ol>
<p>看下移除所有节点的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeAll &#123;&#10;    _totalCost = 0;&#10;    _totalCount = 0;&#10;    _head = nil;&#10;    _tail = nil;&#10;    if (CFDictionaryGetCount(_dic) &#62; 0) &#123;&#10;        CFMutableDictionaryRef holder = _dic;&#10;        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &#38;kCFTypeDictionaryKeyCallBacks, &#38;kCFTypeDictionaryValueCallBacks);&#10;        &#10;        if (_releaseAsynchronously) &#123;&#10;            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();&#10;            dispatch_async(queue, ^&#123;&#10;                CFRelease(holder); // hold and release in specified queue&#10;            &#125;);&#10;        &#125; else if (_releaseOnMainThread &#38;&#38; !pthread_main_np()) &#123;&#10;            dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                CFRelease(holder); // hold and release in specified queue&#10;            &#125;);&#10;        &#125; else &#123;&#10;            CFRelease(holder);&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作。</p>
<h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p>这边介绍两个主要的操作：添加缓存，查找缓存</p><p></p>
<ul>
<li><strong>添加缓存</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123;&#10;    if (!key) return;&#10;    if (!object) &#123;&#10;        // &#32531;&#23384;&#23545;&#35937;&#20026;nil&#65292;&#30452;&#25509;&#31227;&#38500;&#10;        [self removeObjectForKey:key];&#10;        return;&#10;    &#125;&#10;    // &#20026;&#20102;&#20445;&#35777;&#32447;&#31243;&#23433;&#20840;&#65292;&#25968;&#25454;&#25805;&#20316;&#21069;&#36827;&#34892;&#21152;&#38145;&#10;    pthread_mutex_lock(&#38;_lock);&#10;    // &#26597;&#25214;&#32531;&#23384;&#10;    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&#62;_dic, (__bridge const void *)(key));&#10;    // &#24403;&#21069;&#26102;&#38388;&#10;    NSTimeInterval now = CACurrentMediaTime();&#10;    if (node) &#123;&#10;        // &#32531;&#23384;&#23545;&#35937;&#24050;&#23384;&#22312;&#65292;&#26356;&#26032;&#25968;&#25454;&#65292;&#24182;&#31227;&#21040;&#26632;&#39030;&#10;        _lru-&#62;_totalCost -= node-&#62;_cost;&#10;        _lru-&#62;_totalCost += cost;&#10;        node-&#62;_cost = cost;&#10;        node-&#62;_time = now;&#10;        node-&#62;_value = object;&#10;        [_lru bringNodeToHead:node];&#10;    &#125; else &#123;&#10;        // &#32531;&#23384;&#23545;&#35937;&#19981;&#23384;&#22312;&#65292;&#28155;&#21152;&#25968;&#25454;&#65292;&#24182;&#31227;&#21040;&#26632;&#39030;&#10;        node = [_YYLinkedMapNode new];&#10;        node-&#62;_cost = cost;&#10;        node-&#62;_time = now;&#10;        node-&#62;_key = key;&#10;        node-&#62;_value = object;&#10;        [_lru insertNodeAtHead:node];&#10;    &#125;&#10;    // &#21028;&#26029;&#24403;&#21069;&#30340;&#32531;&#23384;&#36827;&#34892;&#26159;&#21542;&#36229;&#20986;&#20102;&#35774;&#23450;&#20540;&#65292;&#33509;&#36229;&#20986;&#21017;&#36827;&#34892;&#25972;&#29702;&#10;    if (_lru-&#62;_totalCost &#62; _costLimit) &#123;&#10;        dispatch_async(_queue, ^&#123;&#10;            [self trimToCost:_costLimit];&#10;        &#125;);&#10;    &#125;&#10;    &#10;    // &#27599;&#27425;&#28155;&#21152;&#25968;&#25454;&#20165;&#26377;&#19968;&#20010;&#65292;&#25968;&#37327;&#19978;&#36229;&#20986;&#26102;&#65292;&#30452;&#25509;&#31227;&#38500;&#23614;&#37096;&#37027;&#20010;object&#21363;&#21487;&#10;    if (_lru-&#62;_totalCount &#62; _countLimit) &#123;&#10;        _YYLinkedMapNode *node = [_lru removeTailNode];&#10;        if (_lru-&#62;_releaseAsynchronously) &#123;&#10;            dispatch_queue_t queue = _lru-&#62;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();&#10;            dispatch_async(queue, ^&#123;&#10;                [node class]; //hold and release in queue&#10;            &#125;);&#10;        &#125; else if (_lru-&#62;_releaseOnMainThread &#38;&#38; !pthread_main_np()) &#123;&#10;            dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;                [node class]; //hold and release in queue&#10;            &#125;);&#10;        &#125;&#10;    &#125;&#10;    // &#25805;&#20316;&#32467;&#26463;&#65292;&#35299;&#38145;&#10;    pthread_mutex_unlock(&#38;_lock);&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>异步线程释放</strong><br><img src="http://7xq5ax.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5%E9%87%8A%E6%94%BE.png" alt=""><br>里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：<br></li>
</ul>
<pre><code>- p
1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁
2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有
3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作
4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了
</code></pre><ul>
<li><strong>添加缓存</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36825;&#36793;&#20174;memory&#20013;&#21462;&#25968;&#25454;&#26102;&#65292;&#26681;&#25454;LRU&#21407;&#21017;&#65292;&#23558;&#26368;&#26032;&#21462;&#20986;&#30340;object&#25918;&#21040;&#26632;&#22836;&#10;- (id)objectForKey:(id)key &#123;&#10;    if (!key) return nil;&#10;    pthread_mutex_lock(&#38;_lock);&#10;    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&#62;_dic, (__bridge const void *)(key));&#10;    if (node) &#123;&#10;        node-&#62;_time = CACurrentMediaTime();&#10;        [_lru bringNodeToHead:node];&#10;    &#125;&#10;    pthread_mutex_unlock(&#38;_lock);&#10;    return node ? node-&#62;_value : nil;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h2><p>该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。</p><p><br>下边分别对Save、Remove、Get分别进行分析</p>
<ul>
<li><strong>Save</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123;&#10;    // &#26465;&#20214;&#19981;&#31526;&#21512;&#10;    if (key.length == 0 || value.length == 0) return NO;&#10;    if (_type == YYKVStorageTypeFile &#38;&#38; filename.length == 0) &#123;&#10;        return NO;&#10;    &#125;&#10;    &#10;    if (filename.length) &#123;    // filename&#23384;&#22312; SQLite File&#20004;&#31181;&#26041;&#24335;&#24182;&#34892;&#10;        // &#29992;&#25991;&#20214;&#36827;&#34892;&#23384;&#20648;&#10;        if (![self _fileWriteWithName:filename data:value]) &#123;&#10;            return NO;&#10;        &#125;&#10;        // &#29992;SQLite&#36827;&#34892;&#23384;&#20648;&#10;        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;&#10;            // &#24403;&#20351;&#29992;SQLite&#26041;&#24335;&#23384;&#20648;&#22833;&#36133;&#26102;&#65292;&#21024;&#38500;&#26412;&#22320;&#25991;&#20214;&#23384;&#20648;&#10;            [self _fileDeleteWithName:filename];&#10;            return NO;&#10;        &#125;&#10;        return YES;&#10;    &#125; else &#123;               // filename&#19981;&#23384;&#22312; SQLite&#10;        if (_type != YYKVStorageTypeSQLite) &#123;&#10;            // &#36825;&#36793;&#21435;&#21040;filename&#21518;&#65292;&#21024;&#38500;filename&#23545;&#24212;&#30340;file&#25991;&#20214;&#10;            NSString *filename = [self _dbGetFilenameWithKey:key];&#10;            if (filename) &#123;&#10;                [self _fileDeleteWithName:filename];&#10;            &#125;&#10;        &#125;&#10;        // SQLite &#36827;&#34892;&#23384;&#20648;&#10;        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Remove</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemForKey:(NSString *)key &#123;&#10;    if (key.length == 0) return NO;&#10;    switch (_type) &#123;&#10;        case YYKVStorageTypeSQLite: &#123;&#10;            // &#21024;&#38500;SQLite&#25991;&#20214;&#10;            return [self _dbDeleteItemWithKey:key];&#10;        &#125; break;&#10;        case YYKVStorageTypeFile:&#10;        case YYKVStorageTypeMixed: &#123;&#10;            // &#33719;&#21462;filename&#10;            NSString *filename = [self _dbGetFilenameWithKey:key];&#10;            if (filename) &#123;&#10;                // &#21024;&#38500;filename&#23545;&#30340;file&#10;                [self _fileDeleteWithName:filename];&#10;            &#125;&#10;            // &#21024;&#38500;SQLite&#25991;&#20214;&#10;            return [self _dbDeleteItemWithKey:key];&#10;        &#125; break;&#10;        default: return NO;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Get</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)getItemValueForKey:(NSString *)key &#123;&#10;    if (key.length == 0) return nil;&#10;    NSData *value = nil;&#10;    switch (_type) &#123;&#10;        case YYKVStorageTypeFile: &#123; //File&#10;            NSString *filename = [self _dbGetFilenameWithKey:key];&#10;            if (filename) &#123;&#10;                // &#26681;&#25454;filename&#33719;&#21462;File&#10;                value = [self _fileReadWithName:filename];&#10;                if (!value) &#123;&#10;                    // &#24403;value&#19981;&#23384;&#22312;&#65292;&#29992;&#23545;&#24212;&#30340;key&#21024;&#38500;SQLite&#25991;&#20214;&#10;                    [self _dbDeleteItemWithKey:key];&#10;                    value = nil;&#10;                &#125;&#10;            &#125;&#10;        &#125; break;&#10;        case YYKVStorageTypeSQLite: &#123;&#10;            // SQLite &#26041;&#24335;&#33719;&#21462;&#10;            value = [self _dbGetValueWithKey:key];&#10;        &#125; break;&#10;        case YYKVStorageTypeMixed: &#123;&#10;            NSString *filename = [self _dbGetFilenameWithKey:key];&#10;            // filename &#23384;&#22312;&#25991;&#20214;&#33719;&#21462;&#65292;&#19981;&#23384;&#22312;SQLite&#26041;&#24335;&#33719;&#21462;&#10;            if (filename) &#123;&#10;                value = [self _fileReadWithName:filename];&#10;                if (!value) &#123;&#10;                    [self _dbDeleteItemWithKey:key];&#10;                    value = nil;&#10;                &#125;&#10;            &#125; else &#123;&#10;                value = [self _dbGetValueWithKey:key];&#10;            &#125;&#10;        &#125; break;&#10;    &#125;&#10;    if (value) &#123;&#10;        // &#26356;&#26032;&#25991;&#20214;&#25805;&#20316;&#26102;&#38388;&#10;        [self _dbUpdateAccessTimeWithKey:key];&#10;    &#125;&#10;    return value;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>File方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下</p>
<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p>YYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithPath:(NSString *)path&#10;             inlineThreshold:(NSUInteger)threshold &#123;&#10;    self = [super init];&#10;    if (!self) return nil;&#10;    &#10;    // &#33719;&#21462;&#32531;&#23384;&#30340; YYDiskCache&#10;    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);&#10;    if (globalCache) return globalCache;&#10;    &#10;    // &#30830;&#23450;&#23384;&#20648;&#30340;&#26041;&#24335;&#10;    YYKVStorageType type;&#10;    if (threshold == 0) &#123;&#10;        type = YYKVStorageTypeFile;&#10;    &#125; else if (threshold == NSUIntegerMax) &#123;&#10;        type = YYKVStorageTypeSQLite;&#10;    &#125; else &#123;&#10;        type = YYKVStorageTypeMixed;&#10;    &#125;&#10;    &#10;    // &#21021;&#22987;&#21270; YYKVStorage&#10;    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];&#10;    if (!kv) return nil;&#10;    &#10;    // &#21021;&#22987;&#21270;&#25968;&#25454;&#10;    _kv = kv;&#10;    _path = path;&#10;    _lock = dispatch_semaphore_create(1);&#10;    _queue = dispatch_queue_create(&#34;com.ibireme.cache.disk&#34;, DISPATCH_QUEUE_CONCURRENT);&#10;    _inlineThreshold = threshold;&#10;    _countLimit = NSUIntegerMax;&#10;    _costLimit = NSUIntegerMax;&#10;    _ageLimit = DBL_MAX;&#10;    _freeDiskSpaceLimit = 0;&#10;    _autoTrimInterval = 60;&#10;    &#10;    // &#36882;&#24402;&#30340;&#21435;&#25972;&#29702;&#25991;&#20214;&#10;    [self _trimRecursively];&#10;    // &#23545;&#24403;&#21069;&#23545;&#35937;&#36827;&#34892;&#32531;&#23384;&#10;    _YYDiskCacheSetGlobal(self);&#10;    &#10;    // &#36890;&#30693; APP&#21363;&#23558;&#34987;&#26432;&#27515;&#26102;&#10;    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];&#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。</p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="external">http://blog.ibireme.com/2015/10/26/yycache/</a></li>
<li><a href="http://blog.csdn.net/yunhua_lee/article/details/7599671" target="_blank" rel="external">http://blog.csdn.net/yunhua_lee/article/details/7599671</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2016/08/25/执着/" class="prev">上一篇</a><a href="/2016/06/21/YYKit-pthread/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">panda</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>